//==============================================================
// Forex Strategy Builder
// Copyright © Miroslav Popov. All rights reserved.
//==============================================================
// THIS CODE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
// EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE.
//==============================================================

using System;
using System.Drawing;
using ForexStrategyBuilder.Infrastructure.Entities;
using ForexStrategyBuilder.Infrastructure.Enums;
using ForexStrategyBuilder.Infrastructure.Interfaces;

namespace ForexStrategyBuilder.Indicators.Store
{
    public class ChandeMomentumOscillator : Indicator
    {
        public ChandeMomentumOscillator()
        {
            IndicatorName  = "Chande Momentum Oscillator";
            PossibleSlots  = SlotTypes.OpenFilter | SlotTypes.CloseFilter;
            SeparatedChart = true;
            SeparatedChartMinValue = -100;
            SeparatedChartMaxValue = 100;

            IndicatorAuthor = "Miroslav Popov";
            IndicatorVersion = "2.0";
            IndicatorDescription = "A custom indicator for FSB and FST.";
        }

        public override void Initialize(SlotTypes slotType)
        {
            SlotType = slotType;

            // ComboBox parameters
            IndParam.ListParam[0].Caption = "Logic";
            IndParam.ListParam[0].ItemList = new string[]
            {
                "CMO rises",
                "CMO falls",
                "CMO is higher than Level line",
                "CMO is lower than Level line",
                "CMO crosses Level line upward",
                "CMO crosses Level line downward",
                "CMO changes its direction upward",
                "CMO changes its direction downward"
            };
            IndParam.ListParam[0].Index    = 0;
            IndParam.ListParam[0].Text     = IndParam.ListParam[0].ItemList[IndParam.ListParam[0].Index];
            IndParam.ListParam[0].Enabled  = true;
            IndParam.ListParam[0].ToolTip  = "Logic of application of the indicator.";

            IndParam.ListParam[2].Caption  = "Base price";
            IndParam.ListParam[2].ItemList = Enum.GetNames(typeof(BasePrice));
            IndParam.ListParam[2].Index    = (int)BasePrice.Close;
            IndParam.ListParam[2].Text     = IndParam.ListParam[2].ItemList[IndParam.ListParam[2].Index];
            IndParam.ListParam[2].Enabled  = true;
            IndParam.ListParam[2].ToolTip  = "The price CMO is based on.";

            // NumericUpDown parameters
            IndParam.NumParam[0].Caption   = "Smoothing period";
            IndParam.NumParam[0].Value     = 14;
            IndParam.NumParam[0].Min       = 1;
            IndParam.NumParam[0].Max       = 200;
            IndParam.NumParam[0].Enabled   = true;
            IndParam.NumParam[0].ToolTip   = "Period of smoothing of CMO value.";

            IndParam.NumParam[1].Caption   = "Level";
            IndParam.NumParam[1].Value     = 30;
            IndParam.NumParam[1].Min       = 0;
            IndParam.NumParam[1].Max       = 100;
            IndParam.NumParam[1].Enabled   = true;
            IndParam.NumParam[1].ToolTip   = "A critical level (for appropriate logic).";

            // CheckBox parameters
            IndParam.CheckParam[0].Caption = "Use previous bar value";
            IndParam.CheckParam[0].Enabled = true;
            IndParam.CheckParam[0].ToolTip = "Use indicator value from previous bar.";
        }

        public override void Calculate(IDataSet dataSet)
        {
            DataSet = dataSet;

            // Reading parameters
            BasePrice basePrice = (BasePrice)IndParam.ListParam[2].Index;
            int       iPeriod   = (int)IndParam.NumParam[0].Value;
            double    dLevel    = IndParam.NumParam[1].Value;
            int       iPrvs     = IndParam.CheckParam[0].Checked ? 1 : 0;

            // Calculation
            int      iFirstBar   = iPeriod + 2;
            double[] adBasePrice = Price(basePrice);
            double[] adCMO1      = new double[Bars];
            double[] adCMO2      = new double[Bars];
            double[] adCMO1Sum   = new double[Bars];
            double[] adCMO2Sum   = new double[Bars];
            double[] adCMO       = new double[Bars];

            for (int iBar = 1; iBar < Bars; iBar++)
            {
                adCMO1[iBar] = 0;
                adCMO2[iBar] = 0;
                if (adBasePrice[iBar] > adBasePrice[iBar - 1])
                    adCMO1[iBar] = adBasePrice[iBar] - adBasePrice[iBar - 1];
                if (adBasePrice[iBar] < adBasePrice[iBar - 1])
                    adCMO2[iBar] = adBasePrice[iBar - 1] - adBasePrice[iBar];
            }

            for (int iBar = 0; iBar < iPeriod; iBar++)
            {
                adCMO1Sum[iPeriod - 1] += adCMO1[iBar];
                adCMO2Sum[iPeriod - 1] += adCMO2[iBar];
            }

            for (int iBar = iPeriod; iBar < Bars; iBar++)
            {
                adCMO1Sum[iBar] = adCMO1Sum[iBar - 1] + adCMO1[iBar] - adCMO1[iBar - iPeriod];
                adCMO2Sum[iBar] = adCMO2Sum[iBar - 1] + adCMO2[iBar] - adCMO2[iBar - iPeriod];

                if (adCMO1Sum[iBar] + adCMO2Sum[iBar] == 0)
                    adCMO[iBar] = 100;
                else
                    adCMO[iBar] = 100 * (adCMO1Sum[iBar] - adCMO2Sum[iBar]) / (adCMO1Sum[iBar] + adCMO2Sum[iBar]);
            }

            // Saving components
            Component = new IndicatorComp[3];

            Component[0] = new IndicatorComp();
            Component[0].CompName   = "CMO";
            Component[0].DataType   = IndComponentType.IndicatorValue;
            Component[0].ChartType  = IndChartType.Line;
            Component[0].ChartColor = Color.RoyalBlue;
            Component[0].FirstBar   = iFirstBar;
            Component[0].Value      = adCMO;

            Component[1] = new IndicatorComp();
            Component[1].ChartType  = IndChartType.NoChart;
            Component[1].FirstBar   = iFirstBar;
            Component[1].Value      = new double[Bars];

            Component[2] = new IndicatorComp();
            Component[2].ChartType  = IndChartType.NoChart;
            Component[2].FirstBar   = iFirstBar;
            Component[2].Value      = new double[Bars];

            // Sets Component's type
            if (SlotType == SlotTypes.OpenFilter)
            {
                Component[1].DataType = IndComponentType.AllowOpenLong;
                Component[1].CompName = "Is long entry allowed";
                Component[2].DataType = IndComponentType.AllowOpenShort;
                Component[2].CompName = "Is short entry allowed";
            }
            else if (SlotType == SlotTypes.CloseFilter)
            {
                Component[1].DataType = IndComponentType.ForceCloseLong;
                Component[1].CompName = "Close out long position";
                Component[2].DataType = IndComponentType.ForceCloseShort;
                Component[2].CompName = "Close out short position";
            }

            // Calculation of logic
            IndicatorLogic indLogic = IndicatorLogic.It_does_not_act_as_a_filter;

            switch (IndParam.ListParam[0].Text)
            {
                case "CMO rises":
                    indLogic = IndicatorLogic.The_indicator_rises;
                    SpecialValues = new double[1] { 0 };
                    break;

                case "CMO falls":
                    indLogic = IndicatorLogic.The_indicator_falls;
                    SpecialValues = new double[1] { 0 };
                    break;

                case "CMO is higher than Level line":
                    indLogic = IndicatorLogic.The_indicator_is_higher_than_the_level_line;
                    SpecialValues = new double[2] { dLevel, -dLevel };
                    break;

                case "CMO is lower than Level line":
                    indLogic = IndicatorLogic.The_indicator_is_lower_than_the_level_line;
                    SpecialValues = new double[2] { dLevel, -dLevel };
                    break;

                case "CMO crosses Level line upward":
                    indLogic = IndicatorLogic.The_indicator_crosses_the_level_line_upward;
                    SpecialValues = new double[2] { dLevel, -dLevel };
                    break;

                case "CMO crosses Level line downward":
                    indLogic = IndicatorLogic.The_indicator_crosses_the_level_line_downward;
                    SpecialValues = new double[2] { dLevel, -dLevel };
                    break;

                case "CMO changes its direction upward":
                    indLogic = IndicatorLogic.The_indicator_changes_its_direction_upward;
                    SpecialValues = new double[1] { 0 };
                    break;

                case "CMO changes its direction downward":
                    indLogic = IndicatorLogic.The_indicator_changes_its_direction_downward;
                    SpecialValues = new double[1] { 0 };
                    break;

                default:
                    break;
            }

            OscillatorLogic(iFirstBar, iPrvs, adCMO, dLevel, -dLevel, ref Component[1], ref Component[2], indLogic);
        }

        public override void SetDescription()
        {
            string sLevelLong  = IndParam.NumParam[1].ValueToString;
            string sLevelShort = IndParam.NumParam[1].AnotherValueToString(-IndParam.NumParam[1].Value);

            EntryFilterLongDescription  = "" + ToString() + " ";
            EntryFilterShortDescription = "" + ToString() + " ";
            ExitFilterLongDescription   = "" + ToString() + " ";
            ExitFilterShortDescription  = "" + ToString() + " ";

            switch (IndParam.ListParam[0].Text)
            {
                case "CMO rises":
                    EntryFilterLongDescription  += "rises";
                    EntryFilterShortDescription += "falls";
                    ExitFilterLongDescription   += "rises";
                    ExitFilterShortDescription  += "falls";
                    break;

                case "CMO falls":
                    EntryFilterLongDescription  += "falls";
                    EntryFilterShortDescription += "rises";
                    ExitFilterLongDescription   += "falls";
                    ExitFilterShortDescription  += "rises";
                    break;

                case "CMO is higher than Level line":
                    EntryFilterLongDescription  += "is higher than Level " + sLevelLong;
                    EntryFilterShortDescription += "is lower than Level "  + sLevelShort;
                    ExitFilterLongDescription   += "is higher than Level " + sLevelLong;
                    ExitFilterShortDescription  += "is lower than Level "  + sLevelShort;
                    break;

                case "CMO is lower than Level line":
                    EntryFilterLongDescription  += "is lower than Level "  + sLevelLong;
                    EntryFilterShortDescription += "is higher than Level " + sLevelShort;
                    ExitFilterLongDescription   += "is lower than Level "  + sLevelLong;
                    ExitFilterShortDescription  += "is higher than Level " + sLevelShort;
                    break;

                case "CMO crosses Level line upward":
                    EntryFilterLongDescription  += "crosses Level " + sLevelLong  + " upward";
                    EntryFilterShortDescription += "crosses Level " + sLevelShort + " downward";
                    ExitFilterLongDescription   += "crosses Level " + sLevelLong  + " upward";
                    ExitFilterShortDescription  += "crosses Level " + sLevelShort + " downward";
                    break;

                case "CMO crosses Level line downward":
                    EntryFilterLongDescription  += "crosses Level " + sLevelLong  + " downward";
                    EntryFilterShortDescription += "crosses Level " + sLevelShort + " upward";
                    ExitFilterLongDescription   += "crosses Level " + sLevelLong  + " downward";
                    ExitFilterShortDescription  += "crosses Level " + sLevelShort + " upward";
                    break;

                case "CMO changes its direction upward":
                    EntryFilterLongDescription  += "changes its direction upward";
                    EntryFilterShortDescription += "changes its direction downward";
                    ExitFilterLongDescription   += "changes its direction upward";
                    ExitFilterShortDescription  += "changes its direction downward";
                    break;

                case "CMO changes its direction downward":
                    EntryFilterLongDescription  += "changes its direction downward";
                    EntryFilterShortDescription += "changes its direction upward";
                    ExitFilterLongDescription   += "changes its direction downward";
                    ExitFilterShortDescription  += "changes its direction upward";
                    break;

                default:
                    break;
            }
        }

        public override string ToString()
        {
            return IndicatorName +
                (IndParam.CheckParam[0].Checked ? "* (" : " (") +
                IndParam.ListParam[2].Text         + ", " + // Base price
                IndParam.NumParam[0].ValueToString + ")";   // Smoothing period
        }
    }
}
